#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
//#include "images/garbage.h"
#include "images/flappy_l.h"
#include "images/flappy_r.h"
#include "images/ball.h"
#include "images/field.h"
#include "images/FIFA_GBA.h"
#include "images/winner.h"
#include "images/lost.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
    START,
    PLAY_INIT,
    WIN,
    LOSE,
};

struct state {
    int size;
    int points;
    int timer;
    struct player player;
    struct ball ball;
    struct bird_l left_bird;
    enum gba_state g_state;
    int buttons;
};

void delay(int n) {
    // delay for n tenths of a second
    volatile int x = 0;
    for (int i = 0; i < n * 4000; i++)
        x++;
}


int main(void) {
    /* TODO: */
    // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;
    int deltas[] = {-3, -2, -1, 1, 2, 3};
    int ndeltas = sizeof(deltas) / sizeof(deltas[0]);
    // Save current and previous state of button input.
    u32 previousButtons = BUTTONS;
    u32 currentButtons = BUTTONS;
    struct state cs, ps;
    // Load initial application state
    int lSrc;

    struct bird_l *bc;
    struct player *p = &cs.player;


    struct ball *bball = &cs.ball;

    cs.g_state = START;

    u16 const *image = flappy_l;
    while (1) {

        ps = cs;
        currentButtons = BUTTONS; // Load the current state of the buttons

        /* TODO: */
        // Manipulate the state machine below as needed //
        // NOTE: Call waitForVBlank() before you draw

        switch (cs.g_state) {
            case START:
                vBlankCounter = 0;
                if (KEY_DOWN(BUTTON_START, currentButtons)) {
                    bball->size = 4;
                    p->row = 150;
                    p->col = 110;
                    p->cd = 15;
                    p->rd = 10;
                    p->score = 3;
                    lSrc = 1;
                    cs.left_bird.row = HEIGHT - 140 + FLAPPY_L_HEIGHT;
                    cs.left_bird.col = WIDTH - FLAPPY_L_WIDTH;
                    cs.left_bird.rd = FLAPPY_L_HEIGHT;
                    cs.left_bird.cd = FLAPPY_L_WIDTH;
                    cs.left_bird.destination = FLAPPY_L_WIDTH;
                    cs.ball.row = rand() % 80;
                    cs.ball.col = rand() % WIDTH;
                    cs.ball.rd = deltas[rand() % ndeltas];
                    cs.ball.cd = deltas[rand() % ndeltas];
                    p->clicked = 0;
                    bball = &cs.ball;
                    cs.g_state = PLAY_INIT;
                }

                break;
            case PLAY_INIT:

                // Erase the old balls

//                    bp = &ps.left_bird;


                // Draw the new balls

                bc = &cs.left_bird;
                if (bc->col && lSrc) {
                    bc->col -= 4;
                } else {
                    lSrc = 0;
                    image = flappy_r;
                    bc->col += 4;
                    if (bc->col == WIDTH - bc->cd) {
                        image = flappy_l;
                        lSrc = 1;
                    }
                }
                if (KEY_DOWN(BUTTON_LEFT, currentButtons) && p->col > 1) {
                    if (p->col >= 4) {
                        p->col -= 4;
                    } else {
                        p->col -= 2;
                    }

                } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && p->col <= 228) {
                    p->col += 4;
                }


                delay(1);


                /**
                 * so start the ball and make it drop from mid row but random col
                 *
                 * if player has spacebar pressed the moment that the ball hits rectangle, we need to check
                 * if bird has been hit with the ball after the ball bounced off the player.
                 *
                 * if the bird is hit with the ball after the player had impacted with it, let it bounce off the bird in opposite direction.
                 *
                 *
                 * if the ball hits maximum row for any reason, player loses a point. player starts with 3 points.
                 *
                 * if player hits 0 points, game over. if player hits 7 points, they win.
                 */

                bball->row = bball->row + bball->rd;
                bball->col += bball->cd;
                if (bball->row < 0) {
                    bball->row = 0;
                    bball->rd = -bball->rd;
                }
                if (bball->col < (p->col + p->cd)) {
                    if ((bball->col + bball->size) > p->col) {
                        if (bball->row < (p->row + p->rd)) {
                            if ((bball->row + bball->size) > p->row) {
                                bball->row += -(p->row - bball->row + 4);
                                bball->rd = -bball->rd;
                                p->clicked = 1;
                            }
                        }
                    }
                }

                if (bball->col < (bc->col + bc->cd)) {
                    if ((bball->col + bball->size) > bc->col) {
                        if (bball->row < (bc->row + bc->rd)) {
                            if ((bball->row + bball->size) > bc->row) {
                                bball->row += -(bc->row - bball->row + 4);
                                bball->row = bball->row + 4;
                                if (p->clicked) {
                                    p->score++;
                                }
                                p->clicked = 0;
                                bball->row = rand() % 80;
                            }
                        }
                    }
                }


                if (bball->col < 0) {
                    bball->col = 0;
                    bball->cd = -bball->cd;
                }
                if (bball->col > WIDTH - bball->size) {
                    bball->col = WIDTH - bball->size;
                    bball->cd = -bball->cd;
                }

                if (bball->row > HEIGHT - bball->size) {
                    bball->row = HEIGHT - bball->size;
                    bball->rd = -bball->rd;
                    p->clicked = 0;
                    p->score--;
                    bball->row = -(bball->row + 2);
                }
                drawRect(p->row, p->col, 10, 5, RED);

                // state = ?
                break;


            case WIN:
                drawFullScreenImageDMA(winner);

                drawString(100, 100, "WINNER", GREEN);
                // state = ?
                break;
            case LOSE:
                drawFullScreenImageDMA(lost);

                drawString(120, 70, "MISSION FAILED", RED);
                // state = ?
                break;
        }


        switch (cs.g_state) {
            case START:
                drawFullScreenImageDMA(FIFA_GBA);

                drawString(140, 80, "Press Enter", BLACK);
                break;
            case PLAY_INIT:


                if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
                    if (!KEY_DOWN(BUTTON_SELECT, previousButtons)) {
                        cs.g_state = START;
                    }
                }

                if (p->score == 6) {
                    cs.g_state = WIN;
                    break;
                }

                if (p->score == 0) {
                    cs.g_state = LOSE;
                    break;
                }


                drawFullScreenImageDMA(field);

                drawImageDMA(ps.player.row, ps.player.col, 10, 5, field);
                char buffer[51];
                sprintf(buffer, "Score: %d", p->score);
                drawString(10, 185, buffer, RED);

                sprintf(buffer, "Time: %d.%d", (vBlankCounter) / 30, (2 * (vBlankCounter) % 60));
                drawString(20, 170, buffer, RED);



                // Erase the old bird


                drawImageDMA(ps.left_bird.row, ps.left_bird.col, FLAPPY_L_WIDTH, FLAPPY_L_HEIGHT, field);
                drawImageDMA(cs.left_bird.row, cs.left_bird.col, FLAPPY_L_WIDTH, FLAPPY_L_HEIGHT, image);


                drawImageDMA(p->row, p->col, 10, 5, field);
                drawRect(p->row, p->col, 10, 5, RED);

//                // Erase the old ball
                drawImageDMA(ps.ball.row, ps.ball.col, ps.ball.size, ps.ball.size, field);

                drawRectDMA(bball->row, bball->col, bball->size, bball->size, BLUE); //ball
                // Draw the new bird
                drawImageDMA(bc->row, bc->col, cs.left_bird.cd, cs.left_bird.rd, image);



                //erase old rectangle




                // state = ?
                break;


            case WIN:
                if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
                    if (!KEY_DOWN(BUTTON_SELECT, previousButtons)) {
                        cs.g_state = START;
                    }
                }
                // state = ?
                break;
            case LOSE:
                if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
                    if (!KEY_DOWN(BUTTON_SELECT, previousButtons)) {
                        cs.g_state = START;
                    }
                }

                // state = ?
                break;
        }
        waitForVBlank();
        previousButtons = currentButtons; // Store the current state of the buttons
    }

    UNUSED(previousButtons); // You can remove this once previousButtons is used

    return 0;
}
